"""
Display test patterns
=====================

This script generates PNG images showing the test pictures generated by
:py:func:`vc2_bit_widths.helpers.generate_test_pictures`. It is intended for
informative purposes only.

Example usage::

    $ vc2-static-filter-analysis -w le_gall_5_3 -d 2 -o le_gall_2.json
    $ mkdir test_patterns
    $ python preview_test_pattern.py le_gall_2.json -b 10 -o test_patterns
    $ ls test_patterns
    analysis_0.json             synthesis_2_qi46.png    synthesis_6_qi52.json
    analysis_0.png              synthesis_3_qi49.json   synthesis_6_qi52.png
    synthesis_0_qi38.json       synthesis_3_qi49.png    synthesis_7_qi53.json
    synthesis_0_qi38.png        synthesis_4_qi50.json   synthesis_7_qi53.png
    synthesis_1_qi45.json       synthesis_4_qi50.png    synthesis_8_qi54.json
    synthesis_1_qi45.png        synthesis_5_qi51.json   synthesis_8_qi54.png
    synthesis_2_qi46.json       synthesis_5_qi51.png

"""

import os

import json

import numpy as np

import logging

from imageio import imwrite

from argparse import ArgumentParser, FileType

from vc2_bit_widths.scripts.argument_parsers import (
    parse_quantisation_matrix_argument,
)

from vc2_bit_widths.signal_generation import (
    TestSignalSpecification,
    OptimisedTestSignalSpecification,
)

from vc2_bit_widths.json_serialisations import (
    deserialise_signal_bounds,
    deserialise_test_signals,
    deserialise_quantisation_matrix,
    serialise_namedtuple,
)

from vc2_bit_widths.helpers import (
    evaluate_filter_bounds,
    quantisation_index_bound,
    evaluate_test_signal_outputs,
    generate_test_pictures,
    TestPoint,
)

def parse_args(arg_strings=None):
    parser = ArgumentParser(description="""
        Display the test patterns generated for a VC-2 filter.
    """)
    
    parser.add_argument(
        "static_filter_analysis",
        type=FileType("r"),
        help="""
            The static analysis JSON data produced by
            vc2-static-filter-analysis.
        """,
    )
    
    parser.add_argument(
        "optimised_synthesis_test_signals",
        type=FileType("r"), nargs="?",
        help="""
            A set of optimised synthesis test signals produced by
            vc2-optimise-synthesis-test-signals.
        """,
    )
    
    parser.add_argument(
        "--picture-size", "-s",
        type=int, nargs=2, default=(1920,1080), metavar=("WIDTH", "HEIGHT"),
        help="""
            The dimensions of the test pictures to generate.
        """,
    )
    
    parser.add_argument(
        "--picture-bit-width", "-b",
        type=int,
        help="""
            The number of bits in the picture signal.
        """,
    )
    
    parser.add_argument(
        "--custom-quantisation-matrix", "-q",
        nargs="+",
        help="""
            Use a custom quantisation matrix. Optional except for filters
            without a default quantisation matrix defined. Should be specified
            as a series 3-argument tuples giving the level, orientation and
            quantisation matrix value for every entry in the quantisation
            matrix.
        """,
    )
    
    parser.add_argument(
        "--verbose", "-v", default=0, action="count",
        help="""
            Show more detailed status information during execution.
        """,
    )
    
    parser.add_argument(
        "--output-dir", "-o",
        type=str, default=".",
        help="""
            The directory name to write the test pictures and metadata to (must
            exist).
        """
    )
    
    args = parser.parse_args(arg_strings)
    
    if args.optimised_synthesis_test_signals is not None:
        if (
            args.picture_bit_width is not None or
            args.custom_quantisation_matrix is not None
        ):
            parser.error(
                "--picture-bit-width/-b and --custom-quantisation-matrix/-q "
                "must not be used when optimised synthesis test signals "
                "are provided"
            )
    else:
        if args.picture_bit_width is None:
            parser.error(
                "A --picture-bit-width/-b argument or a set of "
                "optimised synthesis test signals are required."
            )
    
    return args


args = parse_args()

if args.verbose:
    logging.basicConfig(level=logging.INFO)

# Load precomputed signal bounds
static_filter_analysis = json.load(args.static_filter_analysis)
analysis_signal_bounds = deserialise_signal_bounds(
    static_filter_analysis["analysis_signal_bounds"]
)
synthesis_signal_bounds = deserialise_signal_bounds(
    static_filter_analysis["synthesis_signal_bounds"]
)

# Load precomputed test signals
analysis_test_signals = deserialise_test_signals(
    TestSignalSpecification,
    static_filter_analysis["analysis_test_signals"]
)
synthesis_test_signals = deserialise_test_signals(
    TestSignalSpecification,
    static_filter_analysis["synthesis_test_signals"]
)

# Load optimised synthesis signal
if args.optimised_synthesis_test_signals is not None:
    optimised_json = json.load(args.optimised_synthesis_test_signals)
    
    assert static_filter_analysis["wavelet_index"] == optimised_json["wavelet_index"]
    assert static_filter_analysis["wavelet_index_ho"] == optimised_json["wavelet_index_ho"]
    assert static_filter_analysis["dwt_depth"] == optimised_json["dwt_depth"]
    assert static_filter_analysis["dwt_depth_ho"] == optimised_json["dwt_depth_ho"]
    
    args.picture_bit_width = optimised_json["picture_bit_width"]
    
    quantisation_matrix = deserialise_quantisation_matrix(
        optimised_json["quantisation_matrix"]
    )
    
    synthesis_test_signals = deserialise_test_signals(
        OptimisedTestSignalSpecification,
        optimised_json["optimised_synthesis_test_signals"]
    )
else:
    quantisation_matrix = parse_quantisation_matrix_argument(
        args.custom_quantisation_matrix,
        static_filter_analysis["wavelet_index"],
        static_filter_analysis["wavelet_index_ho"],
        static_filter_analysis["dwt_depth"],
        static_filter_analysis["dwt_depth_ho"],
    )

# Compute signal bounds for all specified bit widths
#
# analysis_bounds_dicts = [{(level, array_name, x, y): (lower_bound, upper_bound), ...}, ...]
# synthesis_bounds_dicts = same as above
concrete_analysis_bounds, concrete_synthesis_bounds = evaluate_filter_bounds(
    static_filter_analysis["wavelet_index"],
    static_filter_analysis["wavelet_index_ho"],
    static_filter_analysis["dwt_depth"],
    static_filter_analysis["dwt_depth_ho"],
    analysis_signal_bounds,
    synthesis_signal_bounds,
    args.picture_bit_width,
)

# Find the maximum quantisation index for each bit width
max_quantisation_index = quantisation_index_bound(
    concrete_analysis_bounds,
    quantisation_matrix,
)

# Find test signal output values for each bit width
_, synthesis_test_signal_outputs = evaluate_test_signal_outputs(
    static_filter_analysis["wavelet_index"],
    static_filter_analysis["wavelet_index_ho"],
    static_filter_analysis["dwt_depth"],
    static_filter_analysis["dwt_depth_ho"],
    args.picture_bit_width,
    quantisation_matrix,
    max_quantisation_index,
    analysis_test_signals,
    synthesis_test_signals,
)

analysis_pictures, synthesis_pictures = generate_test_pictures(
    args.picture_size[0],
    args.picture_size[1],
    args.picture_bit_width,
    analysis_test_signals,
    synthesis_test_signals,
    synthesis_test_signal_outputs,
)

for i, pic in enumerate(analysis_pictures):
    png_filename = os.path.join(args.output_dir, "analysis_{}.png".format(i))
    json_filename = os.path.join(args.output_dir, "analysis_{}.json".format(i))
    
    image = np.full(pic.picture.shape, 128, np.uint8)
    image[pic.picture > 0] = 255
    image[pic.picture < 0] = 0
    
    imwrite(png_filename, image)
    
    with open(json_filename, "w") as f:
        json.dump([
            serialise_namedtuple(TestPoint, test_point)
            for test_point in pic.test_points
        ], f)

for i, pic in enumerate(synthesis_pictures):
    png_filename = os.path.join(args.output_dir, "synthesis_{}_qi{}.png".format(
        i,
        pic.quantisation_index,
    ))
    json_filename = os.path.join(args.output_dir, "synthesis_{}_qi{}.json".format(
        i,
        pic.quantisation_index,
    ))
    
    image = np.full(pic.picture.shape, 128, np.uint8)
    image[pic.picture > 0] = 255
    image[pic.picture < 0] = 0
    
    imwrite(png_filename, image)
    
    with open(json_filename, "w") as f:
        json.dump([
            serialise_namedtuple(TestPoint, test_point)
            for test_point in pic.test_points
        ], f)
