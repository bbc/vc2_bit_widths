
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Test pattern generation &#8212; SMPTE ST 2042-1 (VC-2) Bit Widths 1.0.0 documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Experimental results" href="results.html" />
    <link rel="prev" title="Computing signal bounds with Affine Arithmetic" href="aa_integer_arithmetic.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="results.html" title="Experimental results"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="aa_integer_arithmetic.html" title="Computing signal bounds with Affine Arithmetic"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">SMPTE ST 2042-1 (VC-2) Bit Widths 1.0.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Test pattern generation</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="test-pattern-generation">
<span id="theory-test-patterns"></span><h1>Test pattern generation<a class="headerlink" href="#test-pattern-generation" title="Permalink to this headline">¶</a></h1>
<p>The signal bounds calculated using affine arithmetic provide hard upper bounds
on signal levels in both analysis and synthesis filters. These theoretical
bounds are complemented with a set of test patterns which are designed to
produce near worst-case signal levels in actual codec implementations.  While
the theoretical bounds computed using affine arithmetic can be over-estimates,
the signal levels reached by these test patterns can be considered a
lower-bound on the true worst-case signal levels. Between these two approaches
a range of plausible signal levels are identified.</p>
<div class="section" id="analysis-filter-test-patterns">
<h2>Analysis filter test patterns<a class="headerlink" href="#analysis-filter-test-patterns" title="Permalink to this headline">¶</a></h2>
<p>VC-2’s analysis filters are <em>nearly</em> linear, modulo rounding errors. Since
these rounding errors are small, we can produce an acceptable test pattern
by treating the analysis filter as a true linear filter.</p>
</div>
<div class="section" id="synthesis-filter-test-patterns">
<h2>Synthesis filter test patterns<a class="headerlink" href="#synthesis-filter-test-patterns" title="Permalink to this headline">¶</a></h2>
<p>The input to VC-2’s synthesis filter is a set of transform domain coefficients
produced by analysing, quantising and then dequantising a picture:</p>
<img alt="A pipeline: input, analysis, quantisation, dequantisation, synthesis, output." src="../_images/analysis_quantisation_synthesis_pipeline.svg" /><p>In the figure below lets work backward through the pipeline starting with an
output pixel, (1).</p>
<img alt="A diagram showing how the set of values which influences a particular output value grows through the filter." src="../_images/filter_pixel_influences.svg" /><p>The output pixel is computed using a particular set of transform coefficients,
(2), generated by the analysis transform (and mutated by the
quantisation/dequantisation step).</p>
<p>Each of the transform coefficients in (2) are ultimately the result of
filtering a particular region of the input picture (3).</p>
<p>In the absence of quantisation, only the value of the input pixel, (4), has any
effect on the output pixel, (1).</p>
<p>When quantisation perturbs transform coefficients, the contributions of values
of other pixels in (3) cease to exactly cancel out and begin to effect the
output pixel, (1).</p>
<div class="section" id="heuristic-synthesis-test-pattern">
<h3>Heuristic synthesis test pattern<a class="headerlink" href="#heuristic-synthesis-test-pattern" title="Permalink to this headline">¶</a></h3>
<p>To devise a test pattern which maximises a synthesis decoder value, a simple
heuristic is employed: the larger the magnitude of the transform coefficients,
the larger the energy that can leak into the target value.</p>
<p>A test pattern which simultaneously attempts to maximise the synthesis
target value and the transform coefficients is constructed from a ‘collage’ of
test patterns like so:</p>
<ol class="arabic">
<li><p>Start with an empty test pattern.</p></li>
<li><p>Ignoring all non-linearities, enumerate the set of transform coefficients
(and their weights) that contribute to the target output of the synthesis
filter (labelled ‘(2)’ in the previous illustration).  For each transform
coefficient in turn, in ascending order of weight magnitude:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>Compute the test pattern which maximises this transform coefficient in
isolation (i.e. the same way the analysis filter test patterns were
produced).</p></li>
<li><p>If this transform coefficient has a negative weight, invert the test
pattern found in ‘a’.</p></li>
<li><p>Copy the transform coefficient maximising test pattern into our test
pattern, overwriting any previously set pixel values.</p></li>
</ol>
</div></blockquote>
</li>
<li><p>Ignoring all non-linearities, enumerate the input pixels which directly
contribute to the target synthesis filter output (e.g. pixel ‘(4)’ in the
earlier illustration). For each pixel with a positive weight, set the
corresponding pixel in our test pattern to its maximum value. For pixels
with a negative weight, set the corresponding pixel to the minimum value.</p></li>
</ol>
<p>The resulting stack-up of test patterns is illustrated in the figure below:</p>
<img alt="The stack-up of test patterns which combine to produce the final test pattern." src="../_images/test_pattern_construction.svg" /><p>This test pattern first-and-foremost prioritises features which directly
maximise the target value. Next priority is given to features which maximise
the transform coefficients with the largest weight (and therefore largest
influence on the target value).</p>
</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Test pattern generation</a><ul>
<li><a class="reference internal" href="#analysis-filter-test-patterns">Analysis filter test patterns</a></li>
<li><a class="reference internal" href="#synthesis-filter-test-patterns">Synthesis filter test patterns</a><ul>
<li><a class="reference internal" href="#heuristic-synthesis-test-pattern">Heuristic synthesis test pattern</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="aa_integer_arithmetic.html"
                        title="previous chapter">Computing signal bounds with Affine Arithmetic</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="results.html"
                        title="next chapter">Experimental results</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/theory_and_design/test_patterns.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="results.html" title="Experimental results"
             >next</a> |</li>
        <li class="right" >
          <a href="aa_integer_arithmetic.html" title="Computing signal bounds with Affine Arithmetic"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">SMPTE ST 2042-1 (VC-2) Bit Widths 1.0.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Test pattern generation</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, BBC.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.3.
    </div>
  </body>
</html>