Using the command-line tools
============================

A series of command-line tools are provided for computing signal bounds and
test patterns for arbitrary VC-2 codec configurations.

The first step is to perform a static analysis of the wavelet filter used with
the :ref:`vc2-static-filter-analysis` command::

    $ vc2-static-filter-analysis \
        --wavelet-index le_gall_5_3 \
        --wavelet-index-ho haar_no_shift \
        --dwt-depth 1 \
        --dwt-depth-ho 2 \
        --output static_analysis.json

This command constructs a detailed algebraic description of the complete filter
specified and uses this to determine the relationship between pictures and
internal signal ranges. In addition, it also constructs test patterns which use
heuristics which attempt to produce extreme signal values.

.. warning::

    This command can take some time to run (e.g. a few minutes for particularly
    deep transforms or complex wavelets). The ``--verbose`` argument will give
    an indication of progress during particularly long runs.

The ``static_analysis.json`` file generated by the above example will contain
the JSON serialised output of the analysis which includes formulae for
calculating signal ranges and descriptions of test patterns (see
:ref:`vc2-static-filter-analysis-json` for details).


Tabulating bit width requirements
---------------------------------

We can now turn this JSON file into a human-readable table of signal ranges for
particular picture bit depths using the :ref:`vc2-bit-widths-table` command::

    $ vc2-bit-widths-table \
        static_analysis.json \
        --picture-bit-widths 8 10 16 \
        --output bit_widths_table.csv

In the example above, we request that the bit widths required for 8, 10 and
16 bit input pictures are computed and written to ``bit_width_table.csv``. This
can be displayed in any spreadsheet package or, on UNIX-like systems, can be
displayed in tabular form using::

    $ column -t -s, bit_widths_table.csv

The table produced in the example above is shown (truncated) below:

=========  =====  ==========  =====  =====  ====  =====  =====  ====  =======  ======  ====
type       level  array_name  lower  upper  bits  lower  upper  bits  lower    upper   bits
=========  =====  ==========  =====  =====  ====  =====  =====  ====  =======  ======  ====
analysis   3      Input       -128   127    8     -512   511    10    -32768   32767   16
...        ...    ...         ...    ...    ...   ...    ...    ...   ...      ...     ...
analysis   1      L           -195   195    9     -771   771    11    -49155   49155   17
analysis   1      H           -388   389    10    -1540  1541   12    -98308   98309   18
synthesis  1      L           -272   272    10    -1086  1086   12    -69512   69512   18
synthesis  1      H           -543   543    11    -2173  2173   13    -139023  139023  19
...        ...    ...         ...    ...    ...   ...    ...    ...   ...      ...     ...
synthesis  3      Output      -1861  1858   12    -7424  7421   14    -474661  474658  20
=========  =====  ==========  =====  =====  ====  =====  =====  ====  =======  ======  ====

This table shows, for each input picture bit width specified, lower and upper
bounds for the signal levels in different parts of an analysis filter (encoder)
and synthesis filter (decoder). The 'bits' column gives the minimum number of
bits required to represent signed two's compliment integers in that range.

Each row is labelled with the transform level and array which the bounds apply
to according to the :ref:`naming convention <terminology>` defined earlier.
For example, the first row (analysis, level 3, 'Input') contains the signal
range for the picture presented to the analysis filter (encoder).

The row labelled (analysis, level 1, 'L') gives the signal range for the output
of the final DC band of the analysis filter. The row (synthesis, level 1, 'L')
gives the signal range for the same DC band input to the synthesis filter
(encoder). Notice that the signal range is larger: (-1086 1086) at the
synthesis input vs (-771, 771) at the analysis output. This is because the
signal ranges of the synthesis filter inputs are scaled up to account for the
worst-case effects of quantisation errors.

The signal bounds displayed use a mathematical technique called
:ref:`affine-arithmetic` to bound the worst-case impact of integer rounding
errors and quantisation. This technique guarantees that the signal ranges
produced are at least as wide as the true worst-case signal, therefore using
the number of bits specified in this table will always be sufficient for
correct behaviour. Unfortunately, these bounds tend to over-estimate the signal
bounds by an amount proportional to the size of the potential rounding errors.

In the analysis filter (encoder) rounding errors, and consequently the
over-estimate of signal bounds is likely to be very slight and so the number of
bits suggested in the table is likely to be the true minimum number of bits
required.

Values entering the synthesis filter (decoder) are the product of a
quantisation step which can, in extreme cases, introduce very large errors.
Consequently, the signal bounds for synthesis filters are likely to be
non-trivial over-estimates and so it is possible that fewer bits are required
than specified in the table.


Optimising test signals
-----------------------

The test signals created by the :ref:`vc2-static-filter-analysis` command
are designed to be likely to produce extreme signal values in codecs using the
specified wavelet filters in the general case.

For analysis filters (encoders), the test signals produced by
:ref:`vc2-static-filter-analysis` are likely to produce signal levels very
close to the true worst case. The test signals work well here because the
synthesis filter only includes very slight non-linearities due to integer
rounding errors.

The test signals for synthesis filters (decoders), however, have to contend
with the strong non-linearity introduced by quantisation. The test signals are
designed to exacerbate the effects of these non linearities in the general
case.  However, non-linear effects differ significantly at different input
picture bit widths and when different quantisation matrices are used.

The :ref:`vc2-optimise-synthesis-test-signals` command uses an optimisation
algorithm to enhance the generic synthesis test signals for a particular codec
configuration (picture bit width and quantisation matrix). The resulting test
signals are highly specific to the chosen codec configuration and typically
demonstrate significantly wider signal ranges than the generic test signals.

The command may be used as follows::

    $ vc2-optimise-synthesis-test-signals \
        static_analysis.json \
        --picture-bit-width 10 \
        --output optimised_synthesis_test_signals.json

Custom quantisation matrices may be provided but the default quantisation
matrix will be used if none are specified.

The optimisation algorithm has a number of parameters which must be tuned to
achieve the best results. (See
:ref:`vc2-optimise-synthesis-test-signals-tuning`).

The optimisation process is computationally intensive and may take many hours
depending on the parameters chosen, the transform depth and wavelet complexity.
The ``--verbose`` flag may be used to track progress.

The optimised test patterns are output in JSON format to the specified file
(see :ref:`vc2-optimise-synthesis-test-signals-json` for details).
